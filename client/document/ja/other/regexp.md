## 概要
ZpDIC Online は正規表現による検索に対応しています。
辞書ページの検索欄の下にある「正規」を選択すると、検索フォーム内の文字列を正規表現として解釈して検索を行います。

「正規表現」とは、文字列が満たすべき条件を表現するための形式です。
正規表現を使うことで、例えば「最初に〈a〉から始まって途中に〈sk〉を含む」や「途中に同じ文字の連続を含む」などの条件を表現することができます。
これにより、通常なら前方一致や部分一致を組み合わせる必要がある複雑な検索を、手軽に行うことができるようになります。

このドキュメントでは、正規表現の書き方の基本を解説します。

## 文字
まず前提として、正規表現における検索は基本的に部分一致です。
別の言い方をすれば、正規表現とは文字列の条件を表現するものだと最初に説明しましたが、検索対象の文字列の中にその条件を満たす箇所が存在していればヒットするということです。

さて、正規表現を書く上で最も基本となるルールは、単なる文字は「その文字自身である」という条件を表すということです。
例えば、`a` という正規表現は「〈a〉という文字である」という条件を表します。
したがって、`a` という正規表現で検索すると、検索対象の中に「〈a〉という文字である」を満たす箇所が存在していればヒットすることになるので、結果的に〈a〉を含む文字列がヒットするわけです。

以下に、正規表現による検索を試せるフォームを用意しました。
右端の「試す」をクリックすると検索ウィンドウが開くので、検索対象に様々な文字列を入れて、〈a〉を含む文字列はヒットし〈a〉を含まない文字列はヒットしないことを確認してみてください。
検索結果欄には、検索対象がヒットしたかヒットしないかに加え、正規表現が表す条件を満たしている箇所も表示されます。
```regexp-try
a
```

さて、`a` は「〈a〉という文字である」という条件を表し、`m` が「〈m〉という文字である」という条件を表すのでした。
この 2 つの正規表現を順に並べて `am` とすると、「〈a〉という文字のすぐ次に〈m〉という文字がある」という条件を表します。
その結果、`am` という正規表現は「〈am〉という文字列である」という条件を表すことになり、〈am〉を含む文字列を検索することができます。
文字を 3 つ以上並べても同様で、`ambi` とすれば「〈ambi〉という文字列である」という条件になるので、〈ambi〉を含む文字列が検索されます。
```regexp-try
ambi
```
より一般的なルールとして述べれば、複数の正規表現を並べると、それらの正規表現が表す条件を順番に満たしているという 1 つの条件を表すようになるということです。

## ワイルドカード — 「何でも良いから 1 文字」
ここまでの話だけでは、`ambi` と書くと〈ambi〉を含む文字列が検索されるということなので、単なる正規表現を使わない部分一致検索と何も変わりません。
しかし、正規表現にはいくつかの特殊な記号や構文が用意されていて、これにより複雑な条件を記述することができるようになっています。
最初に紹介するのは `.` です。

`.` はいわゆるワイルドカードで、「何でも良いから何か 1 文字」という条件を表します。
これ単独ではあまり意味はなく、前後に別の正規表現を置いて使うことが多いです。
例えば、`a.k` とすると、これは「〈a〉という文字」と「何でも良いから 1 文字」と「〈k〉という文字」をそれぞれ表す正規表現の羅列なので、これらを順に満たすという条件、すなわち「〈a〉の後に何か 1 文字挟まって次に〈k〉が来る」という条件を表します。
正規表現は部分一致であることを思い出すと、`a.k` という正規表現は例えば〈ask〉や〈ankle〉や〈talk〉などがヒットします。
```regexp-try
a.k
```
他にも、`.` を複数個使って `a.p.e` とすれば「〈a〉と〈p〉と〈e〉の間にそれぞれ 1 文字入る」という条件を表すので、例えば〈apple〉や〈sample〉や〈raspberry〉などがヒットします。
```regexp-try
a.p.e
```
また、`..` とすると「何でも良いから 1 文字」が 2 つ連続していることから「何でも良いから 2 文字」を表すので、`st..ng` は「〈st〉と〈ng〉の間に 2 文字入る」を表し、〈strong〉や〈strange〉などがヒットします。
```regexp-try
st..ng
```
なお、同じ `.` という記号を使っているからといって、2 つの `.` が必ず同じ文字にヒットするとは限らないので注意してください。
あくまで `.` がそれぞれ「何でも良いから 1 文字」を表します。

ここで、`.` について特に注意すべき点が 2 つあります。
まず、これは 1 文字を表す条件であり、複数文字を表しているわけではないということです。
「ワイルドカード」というと 2 文字以上を含める任意の文字列にマッチするような印象があるかもしれませんが、正規表現の `.` は 1 文字だけにマッチします。
複数文字を表す方法については、次の節で説明します。

2 つ目の注意点ですが、ワイルドカードを表すのに `*` という記号を使っている検索プログラムがありますが、これは正規表現ではありません。
正規表現における `*` は別の用途に使います。
混同しないように注意してください。

## 量化子 — 「複数個」の表現
### 1 個以上
正規表現の直後に `+` を付けると、「直前の文字 (もしくは記号) が表す条件を満たすものが 1 個以上連続する」という条件を表します。
例えば、`e+` とすると、「〈e〉という文字」を表す正規表現に `+` が付いているので、「〈e〉が 1 文字以上連続する」という条件を表します。
これを使って `me+t` とすれば、「〈m〉の後に〈e〉が 1 文字以上連続して次に〈t〉が来る」という条件を表すので、〈met〉や〈meet〉や〈meeting〉などがヒットします。
```regexp-try
me+t
```

注意すべき点として、`+` は直前の 1 文字だけに係ります。
前の例の `me+t` では、`+` が係るのは `e` だけなので「〈m〉→〈e〉が 1 個以上→〈t〉の順で並ぶ」という条件を表しているのであり、`+` が `me` に係って「〈me〉が 1 個以上→〈t〉の順で並ぶ」という条件は表しません。
`+` を `me` に係らせて「〈me〉が 1 個以上→〈t〉の順で並ぶ」を表したいときは、括弧によるグルーピングを用いて `(me)+t` のようにする必要があります。
こうすると、〈memetics〉がヒットするようになります。
```regexp-try
(me)+t
```

前の節で説明した `.` に対して `+` を付けて `.+` とすれば、「何らかの 1 文字が 1 個以上連続する」すなわち「何らかの文字複数個」を表せます。
これを使って `m.+t` とすれば、「〈m〉と〈t〉の間に何らかの文字が複数個入る」という条件を表すので、〈mint〉や〈smooth〉などがヒットします。
```regexp-try
m.+t
```
ここで、`+` には「1 個以上連続するときのそれぞれが全く同じ文字列である」という意味合いはないことに注意してください。
つまり、`.+` と書いたからといって、同じ文字列の連続だけがヒットするとは限りません。
したがって、`m.+t` には〈meet〉や〈moot〉の他にも〈mint〉などもヒットすることになります。

このことは括弧によるグループ化を使った場合も同様です。
例えば、`(m.)+t` と書くと、「`m.` にマッチする文字列が複数個連続した後に〈t〉が来る」という条件、もう少し噛み砕けば「〈m〉の後に何か 1 文字という並びが複数個連続した後に〈t〉が来る」という条件を表しますが、連続する「〈m〉の後に何か 1 文字」の部分の〈m〉の後に来る文字は異なっていても構わないことになります。
したがって、〈memento〉の他に、〈m〉の後に〈o〉と〈e〉が続いている〈thermometer〉などもヒットします。
```regexp-try
(m.)+t
```

### 0 個以上
`+` は 1 個以上の繰り返しを表しますが、`*` は 0 個以上の繰り返しを表します。
つまり、`*` の前に置かれた条件を満たす文字列が存在しなくても良いということです。

### 0 個か 1 個

## 文字列頭と文字列末 — 前方一致と後方一致

## 選択
### 文字クラスによる方法

### 論理和による方法